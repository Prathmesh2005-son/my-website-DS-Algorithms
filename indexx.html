<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EDU FUN - DSA Learning Game - Sorting Algorithms</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500&display=swap" rel="stylesheet">
     <a href="index.html">Searching Algorithms</a>
    <script>
        // Global variables
        let currentAlgorithm = 'bubble';
        let arraySize = 8;
        let sortingSpeed = 5;
        let isSorting = false;
        let comparisonCount = 0;
        let swapCount = 0;
        let currentArray = [];
        let quizScores = {};
        
        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            generateArray();
            updateComplexityTable('bubble');
            setupQuizScores();
        });
        
        // Section navigation
        function showSection(sectionId) {
            document.getElementById('visualization-section').style.display = 'none';
            document.getElementById('algorithms-section').style.display = 'none';
            document.getElementById('quiz-section').style.display = 'none';
            
            document.getElementById(sectionId).style.display = 'block';
            
            // Update active tab styling
            const navTabs = document.querySelectorAll('.nav-tab');
            navTabs.forEach(tab => tab.classList.remove('active'));
            
            if (sectionId === 'visualization-section') {
                document.querySelector('.nav-tab:nth-child(1)').classList.add('active');
            } else if (sectionId === 'algorithms-section') {
                document.querySelector('.nav-tab:nth-child(2)').classList.add('active');
            } else if (sectionId === 'quiz-section') {
                document.querySelector('.nav-tab:nth-child(3)').classList.add('active');
            }
        }
        
        // Algorithm selection
        function selectAlgorithm(algo) {
            currentAlgorithm = algo;
            
            // Update active tab styling
            const tabButtons = document.querySelectorAll('.tab-button');
            tabButtons.forEach(button => button.classList.remove('active'));
            
            document.querySelector(`.tab-button[onclick="selectAlgorithm('${algo}')"]`).classList.add('active');
            
            // Update algorithm description
            updateAlgorithmDescription(algo);
            updateComplexityTable(algo);
        }
        
        function updateAlgorithmDescription(algo) {
            const descriptions = {
                'bubble': {
                    title: 'Bubble Sort',
                    description: 'Bubble Sort is a simple sorting algorithm that repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order.',
                    steps: [
                        'Compare adjacent elements.',
                        'If the first element is greater than the second, swap them.',
                        'Repeat until the end of the array.',
                        'After each pass, the largest element bubbles up to the end.',
                        'Repeat for all elements except the already sorted ones.'
                    ]
                },
                'selection': {
                    title: 'Selection Sort',
                    description: 'Selection Sort is a simple sorting algorithm that divides the input list into two parts: a sorted sublist and an unsorted sublist. It repeatedly finds the minimum element from the unsorted sublist and moves it to the beginning of the unsorted sublist.',
                    steps: [
                        'Find the minimum element in the unsorted portion.',
                        'Swap it with the first element of the unsorted portion.',
                        'Move the boundary between sorted and unsorted portions one element to the right.',
                        'Repeat until the entire array is sorted.'
                    ]
                },
                'insertion': {
                    title: 'Insertion Sort',
                    description: 'Insertion Sort is a simple sorting algorithm that builds the sorted array one element at a time. It is efficient for small data sets and nearly sorted arrays.',
                    steps: [
                        'Start with the second element (consider the first element as sorted).',
                        'Compare the current element with the previous elements in the sorted subarray.',
                        'Shift all elements greater than the current element one position to the right.',
                        'Insert the current element in the correct position.',
                        'Repeat for all elements in the array.'
                    ]
                },
                'merge': {
                    title: 'Merge Sort',
                    description: 'Merge Sort is an efficient, stable, comparison-based, divide and conquer algorithm. It divides the input array into two halves, recursively sorts them, and then merges the sorted halves.',
                    steps: [
                        'Divide the unsorted list into n sublists, each containing one element.',
                        'Repeatedly merge sublists to produce new sorted sublists.',
                        'Continue until there is only one sublist remaining.'
                    ]
                },
                'quick': {
                    title: 'Quick Sort',
                    description: 'Quick Sort is an efficient, in-place sorting algorithm that uses a divide-and-conquer strategy. It works by selecting a pivot element and partitioning the array around the pivot.',
                    steps: [
                        'Choose a pivot element from the array.',
                        'Partition the array so that all elements less than the pivot come before it, and all elements greater than the pivot come after it.',
                        'Recursively apply the above steps to the sub-arrays formed by the partitioning.'
                    ]
                },
                'heap': {
                    title: 'Heap Sort',
                    description: 'Heap Sort is a comparison-based sorting algorithm that uses a binary heap data structure. It divides the input into a sorted and an unsorted region, and iteratively shrinks the unsorted region.',
                    steps: [
                        'Build a max heap from the input data.',
                        'Swap the root (maximum value) with the last element of the heap.',
                        'Remove the last element from the heap (it\'s now in the sorted position).',
                        'Heapify the root of the tree.',
                        'Repeat until the heap is empty.'
                    ]
                }
            };
            
            const algoInfo = document.getElementById('algo-info');
            const algoData = descriptions[algo];
            
            algoInfo.innerHTML = `
                <h3>${algoData.title}</h3>
                <p>${algoData.description}</p>
                <ol>
                    ${algoData.steps.map(step => `<li>${step}</li>`).join('')}
                </ol>
            `;
        }
        
        function updateComplexityTable(algo) {
            const complexities = {
                'bubble': ['O(n)', 'O(n²)', 'O(n²)', 'O(1)'],
                'selection': ['O(n²)', 'O(n²)', 'O(n²)', 'O(1)'],
                'insertion': ['O(n)', 'O(n²)', 'O(n²)', 'O(1)'],
                'merge': ['O(n log n)', 'O(n log n)', 'O(n log n)', 'O(n)'],
                'quick': ['O(n log n)', 'O(n log n)', 'O(n²)', 'O(log n)'],
                'heap': ['O(n log n)', 'O(n log n)', 'O(n log n)', 'O(1)']
            };
            
            const complexityRow = document.getElementById('complexity-row');
            const algoComplexity = complexities[algo];
            
            complexityRow.innerHTML = `
                <td>${algoComplexity[0]}</td>
                <td>${algoComplexity[1]}</td>
                <td>${algoComplexity[2]}</td>
                <td>${algoComplexity[3]}</td>
            `;
        }
        
        // Array generation and visualization
        function generateArray() {
            if (isSorting) return;
            
            arraySize = parseInt(document.getElementById('array-size').value);
            currentArray = [];
            
            for (let i = 0; i < arraySize; i++) {
                currentArray.push(Math.floor(Math.random() * 100) + 1);
            }
            
            renderArray(currentArray);
            resetCounters();
        }
        
        function renderArray(arr, highlightedIndices = [], sortedIndices = [], extraInfo = {}) {
            const container = document.getElementById('array-container');
            container.innerHTML = '';
            
            arr.forEach((value, index) => {
                const element = document.createElement('div');
                element.className = 'array-element';
                element.textContent = value;
                element.style.height = `${value * 3}px`;
                element.style.lineHeight = `${value * 3}px`;
                
                // Add special classes based on algorithm
                if (currentAlgorithm === 'bubble' && extraInfo.passNumber && index >= arr.length - extraInfo.passNumber) {
                    element.classList.add('sorted');
                }
                
                if (currentAlgorithm === 'selection' && sortedIndices.includes(index)) {
                    element.classList.add('sorted');
                }
                
                if (currentAlgorithm === 'insertion' && sortedIndices.includes(index)) {
                    element.classList.add('sorted');
                }
                
                if (currentAlgorithm === 'merge' && extraInfo.left !== undefined && extraInfo.right !== undefined) {
                    if (index >= extraInfo.left && index <= extraInfo.right) {
                        element.classList.add('merge-range');
                    }
                    if (index === extraInfo.mid) {
                        element.classList.add('merge-mid');
                    }
                }
                
                if (currentAlgorithm === 'quick' && extraInfo.pivot !== undefined) {
                    if (index === extraInfo.pivot) {
                        element.classList.add('pivot');
                    }
                    if (extraInfo.partition !== undefined && index <= extraInfo.partition) {
                        element.classList.add('partitioned');
                    }
                }
                
                if (currentAlgorithm === 'heap') {
                    if (sortedIndices.includes(index)) {
                        element.classList.add('sorted');
                    }
                    if (extraInfo.heapSize !== undefined && index < extraInfo.heapSize) {
                        element.classList.add('in-heap');
                    }
                }
                
                if (highlightedIndices.includes(index)) {
                    element.classList.add('swapping');
                }
                
                if (sortedIndices.includes(index)) {
                    element.classList.add('sorted');
                }
                
                container.appendChild(element);
            });
        }
        
        function resetCounters() {
            comparisonCount = 0;
            swapCount = 0;
            updateCounters();
        }
        
        function updateCounters() {
            document.getElementById('comparison-counter').textContent = `Comparisons: ${comparisonCount}`;
            document.getElementById('swap-counter').textContent = `Swaps: ${swapCount}`;
        }
        
        // Sorting algorithms implementation with visualization
        async function startSorting() {
            if (isSorting) return;
            isSorting = true;
            
            document.getElementById('start-button').disabled = true;
            resetCounters();
            
            const arr = [...currentArray];
            sortingSpeed = parseInt(document.getElementById('speed').value);
            
            switch (currentAlgorithm) {
                case 'bubble':
                    await bubbleSort(arr);
                    break;
                case 'selection':
                    await selectionSort(arr);
                    break;
                case 'insertion':
                    await insertionSort(arr);
                    break;
                case 'merge':
                    await mergeSortVisualization(arr);
                    break;
                case 'quick':
                    await quickSortVisualization(arr);
                    break;
                case 'heap':
                    await heapSortVisualization(arr);
                    break;
            }
            
            // Mark all elements as sorted at the end
            const sortedIndices = Array.from({length: arr.length}, (_, i) => i);
            renderArray(arr, [], sortedIndices);
            
            isSorting = false;
            document.getElementById('start-button').disabled = false;
            currentArray = arr;
        }
        
        // Bubble Sort with improved visualization
        async function bubbleSort(arr) {
            const n = arr.length;
            let sortedIndices = [];
            
            for (let i = 0; i < n - 1; i++) {
                for (let j = 0; j < n - i - 1; j++) {
                    comparisonCount++;
                    updateCounters();
                    
                    // Highlight the elements being compared
                    renderArray(arr, [j, j + 1], sortedIndices, {passNumber: i});
                    await sleep(1000 / sortingSpeed);
                    
                    if (arr[j] > arr[j + 1]) {
                        swapCount++;
                        updateCounters();
                        
                        // Swap elements
                        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
                        
                        // Show the bubbling effect
                        renderArray(arr, [j, j + 1], sortedIndices, {passNumber: i});
                        await sleep(1000 / sortingSpeed);
                    }
                }
                sortedIndices.push(n - i - 1);
            }
            sortedIndices.push(0); // The first element is also sorted now
            return arr;
        }
        
        // Selection Sort with improved visualization
        async function selectionSort(arr) {
            const n = arr.length;
            let sortedIndices = [];
            
            for (let i = 0; i < n - 1; i++) {
                let minIndex = i;
                
                // Visualize the current minimum
                renderArray(arr, [minIndex], sortedIndices);
                await sleep(1000 / sortingSpeed);
                
                for (let j = i + 1; j < n; j++) {
                    comparisonCount++;
                    updateCounters();
                    
                    // Highlight the elements being compared
                    renderArray(arr, [minIndex, j], sortedIndices);
                    await sleep(1000 / sortingSpeed);
                    
                    if (arr[j] < arr[minIndex]) {
                        minIndex = j;
                        
                        // Visualize the new minimum
                        renderArray(arr, [minIndex], sortedIndices);
                        await sleep(1000 / sortingSpeed);
                    }
                }
                
                if (minIndex !== i) {
                    swapCount++;
                    updateCounters();
                    
                    // Swap elements
                    [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];
                    
                    // Highlight the swapped elements
                    renderArray(arr, [i, minIndex], sortedIndices);
                    await sleep(1000 / sortingSpeed);
                }
                
                sortedIndices.push(i);
            }
            sortedIndices.push(n - 1); // The last element is also sorted now
            return arr;
        }
        
        // Insertion Sort with improved visualization
        async function insertionSort(arr) {
            const n = arr.length;
            let sortedIndices = [0]; // First element is considered sorted
            
            for (let i = 1; i < n; i++) {
                let key = arr[i];
                let j = i - 1;
                
                // Highlight the key element
                renderArray(arr, [i], sortedIndices);
                await sleep(1000 / sortingSpeed);
                
                while (j >= 0 && arr[j] > key) {
                    comparisonCount++;
                    updateCounters();
                    
                    // Highlight the elements being compared
                    renderArray(arr, [j, j + 1], sortedIndices);
                    await sleep(1000 / sortingSpeed);
                    
                    arr[j + 1] = arr[j];
                    j--;
                    
                    swapCount++;
                    updateCounters();
                    
                    // Show the shift operation
                    renderArray(arr, [j + 1, j + 2], sortedIndices);
                    await sleep(1000 / sortingSpeed);
                }
                
                arr[j + 1] = key;
                sortedIndices.push(j + 1);
                
                // Show the final insertion
                renderArray(arr, [j + 1], sortedIndices);
                await sleep(1000 / sortingSpeed);
            }
            
            return arr;
        }
        
        // Merge Sort with improved visualization
        async function mergeSortVisualization(arr) {
            await mergeSortHelper(arr, 0, arr.length - 1);
            return arr;
        }
        
        async function mergeSortHelper(arr, l, r) {
            if (l >= r) return;
            
            const m = Math.floor((l + r) / 2);
            
            // Visualize the division
            renderArray(arr, [], [], {left: l, right: r, mid: m});
            await sleep(1000 / sortingSpeed);
            
            await mergeSortHelper(arr, l, m);
            await mergeSortHelper(arr, m + 1, r);
            
            await merge(arr, l, m, r);
        }
        
        async function merge(arr, l, m, r) {
            const n1 = m - l + 1;
            const n2 = r - m;
            
            const L = new Array(n1);
            const R = new Array(n2);
            
            for (let i = 0; i < n1; i++) {
                L[i] = arr[l + i];
            }
            for (let j = 0; j < n2; j++) {
                R[j] = arr[m + 1 + j];
            }
            
            let i = 0, j = 0, k = l;
            
            while (i < n1 && j < n2) {
                comparisonCount++;
                updateCounters();
                
                // Highlight the elements being compared
                renderArray(arr, [l + i, m + 1 + j], [], {left: l, right: r, mid: m});
                await sleep(1000 / sortingSpeed);
                
                if (L[i] <= R[j]) {
                    arr[k] = L[i];
                    i++;
                } else {
                    arr[k] = R[j];
                    j++;
                    swapCount++;
                    updateCounters();
                }
                k++;
                
                // Show the merge operation
                renderArray(arr, [k - 1], [], {left: l, right: r, mid: m});
                await sleep(1000 / sortingSpeed);
            }
            
            while (i < n1) {
                arr[k] = L[i];
                i++;
                k++;
                
                // Show the remaining elements being copied
                renderArray(arr, [k - 1], [], {left: l, right: r, mid: m});
                await sleep(1000 / sortingSpeed);
            }
            
            while (j < n2) {
                arr[k] = R[j];
                j++;
                k++;
                
                // Show the remaining elements being copied
                renderArray(arr, [k - 1], [], {left: l, right: r, mid: m});
                await sleep(1000 / sortingSpeed);
            }
        }
        
        // Quick Sort with improved visualization
        async function quickSortVisualization(arr) {
            await quickSortHelper(arr, 0, arr.length - 1);
            return arr;
        }
        
        async function quickSortHelper(arr, low, high) {
            if (low < high) {
                const pi = await partition(arr, low, high);
                
                await quickSortHelper(arr, low, pi - 1);
                await quickSortHelper(arr, pi + 1, high);
            }
        }
        
        async function partition(arr, low, high) {
            const pivot = arr[high];
            let i = low - 1;
            
            // Highlight the pivot
            renderArray(arr, [high], [], {pivot: high, partition: i});
            await sleep(1000 / sortingSpeed);
            
            for (let j = low; j < high; j++) {
                comparisonCount++;
                updateCounters();
                
                // Highlight the elements being compared
                renderArray(arr, [j, high], [], {pivot: high, partition: i});
                await sleep(1000 / sortingSpeed);
                
                if (arr[j] < pivot) {
                    i++;
                    
                    if (i !== j) {
                        swapCount++;
                        updateCounters();
                        
                        [arr[i], arr[j]] = [arr[j], arr[i]];
                        
                        // Highlight the swapped elements
                        renderArray(arr, [i, j], [], {pivot: high, partition: i});
                        await sleep(1000 / sortingSpeed);
                    }
                }
            }
            
            if (i + 1 !== high) {
                swapCount++;
                updateCounters();
                
                [arr[i + 1], arr[high]] = [arr[high], arr[i + 1]];
                
                // Highlight the final swap with pivot
                renderArray(arr, [i + 1, high], [], {pivot: high, partition: i});
                await sleep(1000 / sortingSpeed);
            }
            
            return i + 1;
        }
        
        // Heap Sort with improved visualization
        async function heapSortVisualization(arr) {
            const n = arr.length;
            let sortedIndices = [];
            
            // Build max heap
            for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {
                await heapify(arr, n, i, sortedIndices);
            }
            
            // Extract elements one by one
            for (let i = n - 1; i > 0; i--) {
                swapCount++;
                updateCounters();
                
                // Move current root to end
                [arr[0], arr[i]] = [arr[i], arr[0]];
                sortedIndices.push(i);
                
                // Highlight the swap
                renderArray(arr, [0, i], sortedIndices, {heapSize: i});
                await sleep(1000 / sortingSpeed);
                
                // Heapify the reduced heap
                await heapify(arr, i, 0, sortedIndices);
            }
            
            sortedIndices.push(0); // The last element is also sorted now
            return arr;
        }
        
        async function heapify(arr, n, i, sortedIndices) {
            let largest = i;
            const left = 2 * i + 1;
            const right = 2 * i + 2;
            
            if (left < n) {
                comparisonCount++;
                updateCounters();
                
                // Highlight the elements being compared
                renderArray(arr, [largest, left], sortedIndices, {heapSize: n});
                await sleep(1000 / sortingSpeed);
                
                if (arr[left] > arr[largest]) {
                    largest = left;
                }
            }
            
            if (right < n) {
                comparisonCount++;
                updateCounters();
                
                // Highlight the elements being compared
                renderArray(arr, [largest, right], sortedIndices, {heapSize: n});
                await sleep(1000 / sortingSpeed);
                
                if (arr[right] > arr[largest]) {
                    largest = right;
                }
            }
            
            if (largest !== i) {
                swapCount++;
                updateCounters();
                
                [arr[i], arr[largest]] = [arr[largest], arr[i]];
                
                // Highlight the swap
                renderArray(arr, [i, largest], sortedIndices, {heapSize: n});
                await sleep(1000 / sortingSpeed);
                
                await heapify(arr, n, largest, sortedIndices);
            }
        }
        
        // Utility functions
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
        
        // Learning section tabs
        function showAlgoTab(tabId) {
            const tabContents = document.querySelectorAll('#algorithms-section .tab-content');
            tabContents.forEach(content => content.classList.remove('active'));
            
            const tabButtons = document.querySelectorAll('#algorithms-section .tab-button');
            tabButtons.forEach(button => button.classList.remove('active'));
            
            document.getElementById(tabId).classList.add('active');
            document.querySelector(`#algorithms-section .tab-button[onclick="showAlgoTab('${tabId}')"]`).classList.add('active');
        }
        
        // Quiz section tabs
        function showQuizTab(tabId) {
            const tabContents = document.querySelectorAll('#quiz-section .tab-content');
            tabContents.forEach(content => content.classList.remove('active'));
            
            const tabButtons = document.querySelectorAll('#quiz-section .tab-button');
            tabButtons.forEach(button => button.classList.remove('active'));
            
            document.getElementById(tabId).classList.add('active');
            document.querySelector(`#quiz-section .tab-button[onclick="showQuizTab('${tabId}')"]`).classList.add('active');
        }
        
        // Quiz functionality
        function setupQuizScores() {
            const algorithms = ['bubble', 'selection', 'insertion', 'merge', 'quick', 'heap'];
            algorithms.forEach(algo => {
                quizScores[algo] = {
                    score: 0,
                    total: 3 // Each quiz has 3 questions
                };
            });
        }
        
        function checkAnswer(element, correctOption) {
            const options = element.parentElement.querySelectorAll('.quiz-option');
            options.forEach(opt => opt.classList.remove('correct', 'incorrect'));
            
            if (element.textContent.startsWith(correctOption + ')')) {
                element.classList.add('correct');
                
                // Update score
                const currentTab = document.querySelector('#quiz-section .tab-content.active').id;
                const algo = currentTab.split('-')[0];
                quizScores[algo].score++;
                
                // Show feedback
                const feedback = element.closest('.quiz-question').nextElementSibling;
                feedback.textContent = 'Correct!';
                feedback.style.color = '#2ecc71';
            } else {
                element.classList.add('incorrect');
                
                // Mark correct answer
                options.forEach(opt => {
                    if (opt.textContent.startsWith(correctOption + ')')) {
                        opt.classList.add('correct');
                    }
                });
                
                // Show feedback
                const feedback = element.closest('.quiz-question').nextElementSibling;
                feedback.textContent = 'Incorrect! Try again.';
                feedback.style.color = '#e74c3c';
            }
            
            // Update score display
            updateQuizScoreDisplay();
        }
        
        function updateQuizScoreDisplay() {
            const currentTab = document.querySelector('#quiz-section .tab-content.active').id;
            const algo = currentTab.split('-')[0];
            const score = quizScores[algo].score;
            const total = quizScores[algo].total;
            
            const scoreElement = document.querySelector(`#${currentTab} .quiz-score`);
            if (scoreElement) {
                scoreElement.textContent = `Score: ${score}/${total}`;
            }
        }
        
        // Drag and drop for quiz steps
        function allowDrop(ev) {
            ev.preventDefault();
            if (ev.target.classList.contains('drop-zone')) {
                ev.target.classList.add('over');
            }
        }
        
        function drag(ev) {
            ev.dataTransfer.setData("text", ev.target.id);
            ev.target.classList.add('dragging');
        }
        
        function drop(ev) {
            ev.preventDefault();
            ev.target.classList.remove('over');
            
            const data = ev.dataTransfer.getData("text");
            const draggedElement = document.getElementById(data);
            
            if (ev.target.classList.contains('drop-zone')) {
                ev.target.appendChild(draggedElement);
                draggedElement.classList.remove('dragging');
            }
        }
        
        function checkBubbleOrder() {
            const dropZones = document.querySelectorAll('#bubble-quiz .drop-zone');
            const correctOrder = ['bubble-step1', 'bubble-step2', 'bubble-step3', 'bubble-step4'];
            let isCorrect = true;
            
            dropZones.forEach((zone, index) => {
                if (zone.children.length === 0 || zone.children[0].id !== correctOrder[index]) {
                    isCorrect = false;
                }
            });
            
            const feedback = document.querySelector('#bubble-quiz .quiz-feedback');
            if (isCorrect) {
                feedback.textContent = 'Correct order! Well done!';
                feedback.style.color = '#2ecc71';
                
                // Update score
                quizScores['bubble'].score++;
                updateQuizScoreDisplay();
            } else {
                feedback.textContent = 'Incorrect order. Try again!';
                feedback.style.color = '#e74c3c';
            }
        }
        
        function checkSelectionOrder() {
            const dropZones = document.querySelectorAll('#selection-quiz .drop-zone');
            const correctOrder = ['selection-step1', 'selection-step2', 'selection-step3', 'selection-step4'];
            let isCorrect = true;
            
            dropZones.forEach((zone, index) => {
                if (zone.children.length === 0 || zone.children[0].id !== correctOrder[index]) {
                    isCorrect = false;
                }
            });
            
            const feedback = document.querySelector('#selection-quiz .quiz-feedback');
            if (isCorrect) {
                feedback.textContent = 'Correct order! Well done!';
                feedback.style.color = '#2ecc71';
                
                // Update score
                quizScores['selection'].score++;
                updateQuizScoreDisplay();
            } else {
                feedback.textContent = 'Incorrect order. Try again!';
                feedback.style.color = '#e74c3c';
            }
        }
        
        // Initialize with a default array
        generateArray();
    </script>
    <style>
       body {
    font-family: 'Orbitron', sans-serif;
    background-color: #f0f4f8;
    color: #2c3e50;
    margin: 0;
    padding: 20px;
    text-align: center;
}

h1 {
    color: #34495e;
    font-size: 48px;
    text-shadow: 0 0 6px #a3c4f3, 0 0 12px #c1f0dc;
}

.container, .tutorial, .quiz, .visualization {
    max-width: 900px;
    margin: 20px auto;
    padding: 20px;
    background-color: #ffffff;
    border-radius: 12px;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    border: 1px solid #d1e3f0;
}

.tutorial p, .quiz p {
    font-size: 18px;
    line-height: 1.8;
    color: #555;
    text-align: left;
}

.array-container {
    display: flex;
    justify-content: center;
    gap: 15px;
    margin-top: 30px;
    align-items: flex-end;
    height: 350px;
}

.array-element {
    width: 60px;
    min-height: 30px;
    background-color: #76b5c5;
    color: white;
    text-align: center;
    line-height: 30px;
    border-radius: 10px 10px 0 0;
    font-size: 20px;
    transition: all 0.5s ease-in-out;
    position: relative;
    box-shadow: 0 0 5px rgba(118, 181, 197, 0.6);
}

.swapping {
    background-color: #f39c12 !important;
    transform: translateY(-20px);
    box-shadow: 0 0 20px #f39c12;
    z-index: 10;
}

.sorted {
    background-color: #2ecc71 !important;
    box-shadow: 0 0 15px #2ecc71;
}

.merge-range {
    background-color: #9b59b6;
}

.merge-mid {
    background-color: #e74c3c;
}

.pivot {
    background-color: #f1c40f;
    color: #2c3e50;
}

.partitioned {
    background-color: #3498db;
}

.in-heap {
    background-color: #e67e22;
}

.button {
    margin: 10px;
    padding: 10px 20px;
    background-color: #5dade2;
    color: white;
    border-radius: 12px;
    cursor: pointer;
    font-size: 18px;
    transition: 0.3s;
    box-shadow: 0 0 10px rgba(93, 173, 226, 0.5);
    border: none;
}

.button:hover {
    background-color: #85c1e9;
    transform: scale(1.05);
    box-shadow: 0 0 15px #aed6f1;
}

.reset-btn {
    background-color: #e74c3c;
}

.submit-btn:active, .reset-btn:active, .button:active {
    transform: scale(0.95);
}

.steps {
    display: flex;
    flex-wrap: wrap;
    gap: 15px;
    justify-content: center;
}

.step {
    background-color: #76b5c5;
    color: white;
    padding: 15px 20px;
    border-radius: 12px;
    cursor: pointer;
    width: 160px;
    text-align: center;
    font-size: 18px;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    transition: transform 0.3s ease, background-color 0.3s, box-shadow 0.3s;
}

.step:hover {
    background-color: #5dade2;
    transform: scale(1.05);
    box-shadow: 0 0 20px rgba(93, 173, 226, 0.5);
}

.step.dragging {
    opacity: 0.6;
    background-color: #e67e22;
}

.drop-zone {
    width: 160px;
    height: 70px;
    border: 2px dashed #aed6f1;
    border-radius: 12px;
    display: flex;
    align-items: center;
    justify-content: center;
    margin-top: 20px;
    background-color: #ecf0f1;
    transition: background-color 0.3s ease, transform 0.3s;
}

.drop-zone.over {
    background-color: #d6eaf8;
    transform: scale(1.05);
}

.step-wrapper {
    display: flex;
    justify-content: space-around;
    margin-top: 20px;
    flex-wrap: wrap;
}

.tab-buttons {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    margin-bottom: 20px;
}

.tab-button {
    padding: 10px 20px;
    margin: 5px;
    background-color: #dfe6e9;
    color: #2980b9;
    border: 1px solid #aed6f1;
    border-radius: 5px;
    cursor: pointer;
    transition: 0.3s;
}

.tab-button.active {
    background-color: #aed6f1;
    color: #154360;
}

.tab-content {
    display: none;
}

.tab-content.active {
    display: block;
}

.complexity-table {
    width: 100%;
    border-collapse: collapse;
    margin: 20px 0;
    border: 1px solid #d6eaf8;
}

.complexity-table th,
.complexity-table td {
    border: 1px solid #d6eaf8;
    padding: 10px;
    text-align: center;
}

.complexity-table th {
    background-color: #ecf0f1;
}

.counter {
    margin-top: 20px;
    font-size: 18px;
    color: #2c3e50;
}

.algo-description {
    text-align: left;
    margin-bottom: 20px;
}

.algo-description ol, .algo-description ul {
    text-align: left;
    color: #5d6d7e;
}

.correct {
    background-color: #2ecc71 !important;
}

.incorrect {
    background-color: #e74c3c !important;
}

.controls {
    display: flex;
    justify-content: center;
    margin-top: 20px;
    flex-wrap: wrap;
}

.speed-control {
    margin: 0 10px;
}

/* Hide all sections initially except visualization */
#algorithms-section, #learn-section, #quiz-section {
    display: none;
}

.nav-tabs {
    display: flex;
    justify-content: center;
    margin-bottom: 30px;
}

.nav-tab {
    padding: 12px 25px;
    background-color: #dfe6e9;
    color: #2980b9;
    cursor: pointer;
    margin: 0 10px;
    border-radius: 10px;
    transition: 0.3s;
    border: 1px solid #aed6f1;
}

.nav-tab:hover {
    background-color: #d6eaf8;
}

.nav-tab.active {
    background-color: #aed6f1;
    color: #154360;
    box-shadow: 0 0 10px rgba(174, 214, 241, 0.7);
}

.quiz-question {
    text-align: left;
    margin-bottom: 30px;
}

.quiz-options {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 10px;
}

.quiz-option {
    background-color: #f2f4f6;
    border: 1px solid #aed6f1;
    padding: 10px 15px;
    border-radius: 5px;
    cursor: pointer;
    transition: 0.3s;
    width: 100%;
    text-align: left;
}

.quiz-option:hover {
    background-color: #e2eaf1;
}

.quiz-feedback {
    margin-top: 20px;
    font-weight: bold;
    height: 50px;
}

.quiz-score {
    margin-top: 20px;
    font-size: 20px;
    font-weight: bold;
}

    </style>
</head>
<body>
    
    

<h1>Sorting Algorithm Visualizer & Learning Tool</h1>

<div class="nav-tabs">
    <div class="nav-tab active" onclick="showSection('visualization-section')">Visualize</div>
    <div class="nav-tab" onclick="showSection('algorithms-section')">Learn</div>
    <div class="nav-tab" onclick="showSection('quiz-section')">Quiz</div>
</div>

<!-- Visualization Section -->
<div id="visualization-section" class="container">
    <h2>Select Sorting Algorithm</h2>
    <div class="tab-buttons">
        <button class="tab-button active" onclick="selectAlgorithm('bubble')">Bubble Sort</button>
        <button class="tab-button" onclick="selectAlgorithm('selection')">Selection Sort</button>
        <button class="tab-button" onclick="selectAlgorithm('insertion')">Insertion Sort</button>
        <button class="tab-button" onclick="selectAlgorithm('merge')">Merge Sort</button>
        <button class="tab-button" onclick="selectAlgorithm('quick')">Quick Sort</button>
        <button class="tab-button" onclick="selectAlgorithm('heap')">Heap Sort</button>
    </div>
    
    <div id="algo-info" class="algo-description">
        <h3>Bubble Sort</h3>
        <p>Bubble Sort is a simple sorting algorithm that repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order.</p>
        <ol>
            <li>Compare adjacent elements.</li>
            <li>If the first element is greater than the second, swap them.</li>
            <li>Repeat until the end of the array.</li>
            <li>After each pass, the largest element bubbles up to the end.</li>
            <li>Repeat for all elements except the already sorted ones.</li>
        </ol>
    </div>

    <div class="complexity-table">
        <table>
            <thead>
                <tr>
                    <th>Time Complexity (Best)</th>
                    <th>Time Complexity (Average)</th>
                    <th>Time Complexity (Worst)</th>
                    <th>Space Complexity</th>
                </tr>
            </thead>
            <tbody>
                <tr id="complexity-row">
                    <td>O(n)</td>
                    <td>O(n²)</td>
                    <td>O(n²)</td>
                    <td>O(1)</td>
                </tr>
            </tbody>
        </table>
    </div>

    <div class="array-container" id="array-container"></div>
    
    <div class="counter" id="comparison-counter">Comparisons: 0</div>
    <div class="counter" id="swap-counter">Swaps: 0</div>
    
    <div class="controls">
        <button class="button" id="start-button" onclick="startSorting()">Start Sorting</button>
        <button class="button" onclick="generateArray()">Generate New Array</button>
        <div class="speed-control">
            <label for="speed">Speed:</label>
            <input type="range" id="speed" min="1" max="10" value="5">
        </div>
        <select id="array-size" class="button">
            <option value="8">8 Elements</option>
            <option value="12">12 Elements</option>
            <option value="16">16 Elements</option>
        </select>
    </div>
</div>

<!-- Learning Section -->
<div id="algorithms-section" class="container">
    <h2>Learn Sorting Algorithms</h2>
    <div class="tab-buttons">
        <button class="tab-button active" onclick="showAlgoTab('bubble-tab')">Bubble Sort</button>
        <button class="tab-button" onclick="showAlgoTab('selection-tab')">Selection Sort</button>
        <button class="tab-button" onclick="showAlgoTab('insertion-tab')">Insertion Sort</button>
        <button class="tab-button" onclick="showAlgoTab('merge-tab')">Merge Sort</button>
        <button class="tab-button" onclick="showAlgoTab('quick-tab')">Quick Sort</button>
        <button class="tab-button" onclick="showAlgoTab('heap-tab')">Heap Sort</button>
    </div>

    <div id="bubble-tab" class="tab-content active">
        <h3>Bubble Sort</h3>
        <p>Bubble Sort is one of the simplest sorting algorithms. It works by repeatedly stepping through the list, comparing adjacent elements, and swapping them if they are in the wrong order.</p>
        <h4>How It Works:</h4>
        <ol>
            <li>Start from the first element and compare it with the next.</li>
            <li>If the current element is greater than the next, swap them.</li>
            <li>Move to the next pair of elements and repeat step 2.</li>
            <li>After reaching the end, the largest element will have "bubbled up" to the last position.</li>
            <li>Repeat the process for n-1 times, where n is the number of elements.</li>
        </ol>
        <h4>Characteristics:</h4>
        <ul>
            <li>Simple to understand and implement</li>
            <li>Poor performance with O(n²) time complexity</li>
            <li>Stable sort (preserves the relative order of equal elements)</li>
            <li>In-place algorithm (requires constant O(1) extra space)</li>
        </ul>
        <pre>
function bubbleSort(arr) {
    let n = arr.length;
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
            }
        }
    }
    return arr;
}
        </pre>
    </div>

    <div id="selection-tab" class="tab-content">
        <h3>Selection Sort</h3>
        <p>Selection Sort is a simple sorting algorithm that divides the input list into two parts: a sorted sublist and an unsorted sublist. It repeatedly finds the minimum element from the unsorted sublist and moves it to the beginning of the unsorted sublist.</p>
        <h4>How It Works:</h4>
        <ol>
            <li>Find the minimum element in the unsorted portion.</li>
            <li>Swap it with the first element of the unsorted portion.</li>
            <li>Move the boundary between sorted and unsorted portions one element to the right.</li>
            <li>Repeat until the entire array is sorted.</li>
        </ol>
        <h4>Characteristics:</h4>
        <ul>
            <li>Simple algorithm with O(n²) time complexity</li>
            <li>Makes fewer swaps compared to Bubble Sort</li>
            <li>Not stable (may change the relative order of equal elements)</li>
            <li>In-place algorithm (requires constant O(1) extra space)</li>
        </ul>
        <pre>
function selectionSort(arr) {
    let n = arr.length;
    for (let i = 0; i < n; i++) {
        let minIndex = i;
        for (let j = i + 1; j < n; j++) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j;
            }
        }
        [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];
    }
    return arr;
}
        </pre>
    </div>

    <div id="insertion-tab" class="tab-content">
        <h3>Insertion Sort</h3>
        <p>Insertion Sort is a simple sorting algorithm that builds the sorted array one element at a time. It is much less efficient on large lists than more advanced algorithms like quicksort, heapsort, or merge sort, but can be efficient for small data sets and nearly sorted arrays.</p>
        <h4>How It Works:</h4>
        <ol>
            <li>Start with the second element (consider the first element as sorted).</li>
            <li>Compare the current element with the previous elements in the sorted subarray.</li>
            <li>Shift all elements greater than the current element one position to the right.</li>
            <li>Insert the current element in the correct position.</li>
            <li>Repeat for all elements in the array.</li>
        </ol>
        <h4>Characteristics:</h4>
        <ul>
            <li>Efficient for small data sets and nearly sorted arrays</li>
            <li>Stable sort (preserves the relative order of equal elements)</li>
            <li>In-place algorithm (requires constant O(1) extra space)</li>
            <li>O(n²) time complexity in average and worst cases, but O(n) in best case (already sorted)</li>
        </ul>
        <pre>
function insertionSort(arr) {
    let n = arr.length;
    for (let i = 1; i < n; i++) {
        let key = arr[i];
        let j = i - 1;
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = key;
    }
    return arr;
}
        </pre>
    </div>

    <div id="merge-tab" class="tab-content">
        <h3>Merge Sort</h3>
        <p>Merge Sort is an efficient, stable, comparison-based, divide and conquer algorithm. It divides the input array into two halves, recursively sorts them, and then merges the sorted halves.</p>
        <h4>How It Works:</h4>
        <ol>
            <li>Divide the unsorted list into n sublists, each containing one element (a list of one element is considered sorted).</li>
            <li>Repeatedly merge sublists to produce new sorted sublists until there is only one sublist remaining.</li>
        </ol>
        <h4>Characteristics:</h4>
        <ul>
            <li>Efficient with O(n log n) time complexity in all cases</li>
            <li>Stable sort (preserves the relative order of equal elements)</li>
            <li>Not an in-place algorithm (requires O(n) extra space)</li>
            <li>Well-suited for external sorting (when data doesn't fit in memory)</li>
        </ul>
        <pre>
function mergeSort(arr) {
    if (arr.length <= 1) return arr;
    
    // Divide array into two halves
    const mid = Math.floor(arr.length / 2);
    const left = arr.slice(0, mid);
    const right = arr.slice(mid);
    
    // Recursively sort both halves
    return merge(mergeSort(left), mergeSort(right));
}

function merge(left, right) {
    let result = [];
    let leftIndex = 0;
    let rightIndex = 0;
    
    // Compare elements from both arrays and merge them in sorted order
    while (leftIndex < left.length && rightIndex < right.length) {
        if (left[leftIndex] < right[rightIndex]) {
            result.push(left[leftIndex]);
            leftIndex++;
        } else {
            result.push(right[rightIndex]);
            rightIndex++;
        }
    }
    
    // Add remaining elements
    return result.concat(left.slice(leftIndex)).concat(right.slice(rightIndex));
}
        </pre>
    </div>

    <div id="quick-tab" class="tab-content">
        <h3>Quick Sort</h3>
        <p>Quick Sort is an efficient, in-place sorting algorithm that uses a divide-and-conquer strategy. It works by selecting a 'pivot' element and partitioning the array around the pivot, placing smaller elements before it and larger elements after it.</p>
        <h4>How It Works:</h4>
        <ol>
            <li>Choose a pivot element from the array.</li>
            <li>Partition the array so that all elements less than the pivot come before it, and all elements greater than the pivot come after it.</li>
            <li>Recursively apply the above steps to the sub-arrays formed by the partitioning.</li>
        </ol>
        <h4>Characteristics:</h4>
        <ul>
            <li>Efficient with average time complexity of O(n log n)</li>
            <li>Worst-case time complexity is O(n²) when poorly implemented or with bad pivot choices</li>
            <li>In-place algorithm (requires O(log n) extra space for recursion)</li>
            <li>Not stable (may change the relative order of equal elements)</li>
        </ul>
        <pre>
function quickSort(arr, low = 0, high = arr.length - 1) {
    if (low < high) {
        let pivotIndex = partition(arr, low, high);
        quickSort(arr, low, pivotIndex - 1);
        quickSort(arr, pivotIndex + 1, high);
    }
    return arr;
}

function partition(arr, low, high) {
    let pivot = arr[high];
    let i = low - 1;
    
    for (let j = low; j < high; j++) {
        if (arr[j] <= pivot) {
            i++;
            [arr[i], arr[j]] = [arr[j], arr[i]];
        }
    }
    
    [arr[i + 1], arr[high]] = [arr[high], arr[i + 1]];
    return i + 1;
}
        </pre>
    </div>

    <div id="heap-tab" class="tab-content">
        <h3>Heap Sort</h3>
        <p>Heap Sort is a comparison-based sorting algorithm that uses a binary heap data structure. It divides the input into a sorted and an unsorted region, and iteratively shrinks the unsorted region by extracting the largest element and moving it to the sorted region.</p>
        <h4>How It Works:</h4>
        <ol>
            <li>Build a max heap from the input data.</li>
            <li>Swap the root (maximum value) with the last element of the heap.</li>
            <li>Remove the last element from the heap (it's now in the sorted position).</li>
            <li>Heapify the root of the tree.</li>
            <li>Repeat steps 2-4 until the heap is empty.</li>
        </ol>
        <h4>Characteristics:</h4>
        <ul>
            <li>Efficient with O(n log n) time complexity in all cases</li>
            <li>In-place algorithm (requires constant O(1) extra space)</li>
            <li>Not stable (may change the relative order of equal elements)</li>
            <li>Good for systems with limited memory resources</li>
        </ul>
        <pre>
function heapSort(arr) {
    let n = arr.length;
    
    // Build max heap
    for (let i = Math.floor(n / 2) - 1; i >= 0; i--)
        heapify(arr, n, i);
    
    // Extract elements one by one
    for (let i = n - 1; i > 0; i--) {
        [arr[0], arr[i]] = [arr[i], arr[0]]; // Swap root with last element
        heapify(arr, i, 0); // Heapify reduced heap
    }
    
    return arr;
}

function heapify(arr, n, i) {
    let largest = i;
    let left = 2 * i + 1;
    let right = 2 * i + 2;
    
    if (left < n && arr[left] > arr[largest])
        largest = left;
    
    if (right < n && arr[right] > arr[largest])
        largest = right;
    
    if (largest !== i) {
        [arr[i], arr[largest]] = [arr[largest], arr[i]];
        heapify(arr, n, largest);
    }
}
        </pre>
    </div>
</div>

<!-- Quiz Section -->
<div id="quiz-section" class="container">
    <h2>Test Your Knowledge</h2>
    <div class="tab-buttons">
        <button class="tab-button active" onclick="showQuizTab('bubble-quiz')">Bubble Sort</button>
        <button class="tab-button" onclick="showQuizTab('selection-quiz')">Selection Sort</button>
        <button class="tab-button" onclick="showQuizTab('insertion-quiz')">Insertion Sort</button>
        <button class="tab-button" onclick="showQuizTab('merge-quiz')">Merge Sort</button>
        <button class="tab-button" onclick="showQuizTab('quick-quiz')">Quick Sort</button>
        <button class="tab-button" onclick="showQuizTab('heap-quiz')">Heap Sort</button>
    </div>

    <div id="bubble-quiz" class="tab-content active">
        <h3>Bubble Sort Quiz</h3>
        
        <div class="quiz-question">
            <p>1. What is the time complexity of Bubble Sort in the worst case?</p>
            <div class="quiz-options">
                <div class="quiz-option" onclick="checkAnswer(this, 'B')">A) O(n log n)</div>
                <div class="quiz-option" onclick="checkAnswer(this, 'B')">B) O(n²)</div>
                <div class="quiz-option" onclick="checkAnswer(this, 'B')">C) O(n)</div>
                <div class="quiz-option" onclick="checkAnswer(this, 'B')">D) O(log n)</div>
            </div>
        </div>
        
        <div class="quiz-question">
            <p>2. Arrange the steps of the Bubble Sort algorithm in the correct order:</p>
            <div class="steps">
                <div id="bubble-step1" class="step" draggable="true" ondragstart="drag(event)">Compare adjacent elements</div>
                <div id="bubble-step2" class="step" draggable="true" ondragstart="drag(event)">If first > second, swap them</div>
                <div id="bubble-step3" class="step" draggable="true" ondragstart="drag(event)">Repeat until end of array</div>
                <div id="bubble-step4" class="step" draggable="true" ondragstart="drag(event)">Repeat for n-1 passes</div>
            </div>
            <div class="step-wrapper">
                <div id="bubble-drop1" class="drop-zone" ondrop="drop(event)" ondragover="allowDrop(event)"></div>
                <div id="bubble-drop2" class="drop-zone" ondrop="drop(event)" ondragover="allowDrop(event)"></div>
                <div id="bubble-drop3" class="drop-zone" ondrop="drop(event)" ondragover="allowDrop(event)"></div>
                <div id="bubble-drop4" class="drop-zone" ondrop="drop(event)" ondragover="allowDrop(event)"></div>
            </div>
            <button class="button" onclick="checkBubbleOrder()">Check Order</button>
        </div>
        
        <div class="quiz-question">
            <p>3. Is Bubble Sort a stable sorting algorithm?</p>
            <div class="quiz-options">
                <div class="quiz-option" onclick="checkAnswer(this, 'A')">A) Yes</div>
                <div class="quiz-option" onclick="checkAnswer(this, 'A')">B) No</div>
            </div>
        </div>
        
        <div class="quiz-feedback"></div>
    </div>

    <div id="selection-quiz" class="tab-content">
        <h3>Selection Sort Quiz</h3>
        
        <div class="quiz-question">
            <p>1. What is the space complexity of Selection Sort?</p>
            <div class="quiz-options">
                <div class="quiz-option" onclick="checkAnswer(this, 'A')">A) O(1)</div>
                <div class="quiz-option" onclick="checkAnswer(this, 'A')">B) O(n)</div>
                <div class="quiz-option" onclick="checkAnswer(this, 'A')">C) O(n log n)</div>
                <div class="quiz-option" onclick="checkAnswer(this, 'A')">D) O(n²)</div>
            </div>
        </div>
        
        <div class="quiz-question">
            <p>2. Arrange the steps of the Selection Sort algorithm in the correct order:</p>
            <div class="steps">
                <div id="selection-step1" class="step" draggable="true" ondragstart="drag(event)">Find minimum in unsorted array</div>
                <div id="selection-step2" class="step" draggable="true" ondragstart="drag(event)">Swap with first unsorted element</div>
                <div id="selection-step3" class="step" draggable="true" ondragstart="drag(event)">Move boundary right by one</div>
                <div id="selection-step4" class="step" draggable="true" ondragstart="drag(event)">Repeat until array is sorted</div>
            </div>
            <div class="step-wrapper">
                <div id="selection-drop1" class="drop-zone" ondrop="drop(event)" ondragover="allowDrop(event)"></div>
                <div id="selection-drop2" class="drop-zone" ondrop="drop(event)" ondragover="allowDrop(event)"></div>
                <div id="selection-drop3" class="drop-zone" ondrop="drop(event)" ondragover="allowDrop(event)"></div>
                <div id="selection-drop4" class="drop-zone" ondrop="drop(event)" ondragover="allowDrop(event)"></div>
            </div>
            <button class="button" onclick="checkSelectionOrder()">Check Order</button>
        </div>
        
        <div class="quiz-question">
            <p>3. Is Selection Sort better than Bubble Sort for nearly sorted arrays?</p>
            <div class="quiz-options">
                <div class="quiz-option" onclick="checkAnswer(this, 'B')">A)Yes</div>
                <div class="quiz-option" onclick="checkAnswer(this, 'B')">B) No</div>
            </div>
        </div>
        
        <div class="quiz-feedback"></div>