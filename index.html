 <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Structures & Algorithms Visualizer</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500&family=Roboto:wght@400;500&display=swap" rel="stylesheet">
 
       <a href="indexx.html">Sorting Algorithms</a>
    <style>
          body {
            font-family: 'Orbitron', sans-serif;
            background-color: #f0f4f8;
            color: #2c3e50;
            margin: 0;
            padding: 20px;
            text-align: center;
        }

        h1, h2, h3 {
            color: #34495e;
            font-family: 'Orbitron', sans-serif;
        }

        h1 {
            font-size: 48px;
            text-shadow: 0 0 6px #a3c4f3, 0 0 12px #c1f0dc;
            margin-bottom: 30px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .section {
            background-color: #ffffff;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 30px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            border: 1px solid #d1e3f0;
        }

        .tab-buttons {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .tab-button {
            padding: 10px 20px;
            margin: 5px;
            background-color: #dfe6e9;
            color: #2980b9;
            border: 1px solid #aed6f1;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .tab-button:hover {
            background-color: #d6eaf8;
        }

        .tab-button.active {
            background-color: #aed6f1;
            color: #154360;
            box-shadow: 0 0 10px rgba(174, 214, 241, 0.7);
        }

        .tab-content {
            display: none;
            padding: 20px;
            background-color: #ffffff;
            border-radius: 8px;
            margin-top: 15px;
            border: 1px solid #d1e3f0;
        }

        .tab-content.active {
            display: block;
        }

        .visualization-container {
            display: flex;
            justify-content: center;
            margin: 30px 0;
            min-height: 300px;
            align-items: center;
        }

        .search-array {
            display: flex;
            justify-content: center;
            align-items: flex-end;
            height: 200px;
        }

        .search-element {
            width: 50px;
            margin: 0 5px;
            background-color: #76b5c5;
            color: white;
            text-align: center;
            padding: 10px 0;
            border-radius: 5px 5px 0 0;
            transition: all 0.3s;
            position: relative;
            box-shadow: 0 0 5px rgba(118, 181, 197, 0.6);
        }

        .search-element.current {
            background-color: #f39c12;
            transform: translateY(-20px);
            box-shadow: 0 0 20px #f39c12;
        }

        .search-element.found {
            background-color: #2ecc71;
            box-shadow: 0 0 15px #2ecc71;
        }

        .search-element.checked {
            background-color: #9b59b6;
        }

        .ds-array {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 10px;
            margin: 20px 0;
        }

        .array-cell {
            width: 60px;
            height: 60px;
            background-color: #76b5c5;
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 5px;
            font-weight: bold;
            box-shadow: 0 0 5px rgba(118, 181, 197, 0.6);
        }

        .stack-container {
            display: flex;
            flex-direction: column-reverse;
            align-items: center;
            margin: 20px 0;
        }

        .stack-element {
            width: 100px;
            height: 50px;
            background-color: #76b5c5;
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 2px 0;
            border-radius: 5px;
            transition: all 0.3s;
            box-shadow: 0 0 5px rgba(118, 181, 197, 0.6);
        }

        .stack-element.active {
            background-color: #f39c12;
            transform: scale(1.05);
            box-shadow: 0 0 20px #f39c12;
        }

        .queue-container {
            display: flex;
            justify-content: center;
            margin: 20px 0;
        }

        .queue-element {
            width: 80px;
            height: 60px;
            background-color: #76b5c5;
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 0 5px;
            border-radius: 5px;
            transition: all 0.3s;
            box-shadow: 0 0 5px rgba(118, 181, 197, 0.6);
        }

        .queue-element.active {
            background-color: #f39c12;
            transform: scale(1.05);
            box-shadow: 0 0 20px #f39c12;
        }

        .linked-list-container {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 30px 0;
        }

        .node {
            display: flex;
            align-items: center;
            margin: 0 10px;
        }

        .node-value {
            width: 50px;
            height: 50px;
            background-color: #76b5c5;
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 5px;
            font-weight: bold;
            box-shadow: 0 0 5px rgba(118, 181, 197, 0.6);
        }

        .node-pointer {
            width: 30px;
            height: 3px;
            background-color: #5dade2;
            position: relative;
        }

        .node-pointer::after {
            content: '';
            position: absolute;
            right: 0;
            top: -5px;
            width: 0;
            height: 0;
            border-top: 7px solid transparent;
            border-bottom: 7px solid transparent;
            border-left: 10px solid #5dade2;
        }

        .node.active .node-value {
            background-color: #f39c12;
            box-shadow: 0 0 20px #f39c12;
        }

        .tree-container {
            display: flex;
            justify-content: center;
            margin: 30px 0;
        }

        .tree {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .tree-level {
            display: flex;
            justify-content: center;
            margin: 20px 0;
        }

        .tree-node {
            width: 50px;
            height: 50px;
            background-color: #76b5c5;
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 50%;
            margin: 0 20px;
            position: relative;
            font-weight: bold;
            box-shadow: 0 0 5px rgba(118, 181, 197, 0.6);
        }

        .tree-node.active {
            background-color: #f39c12;
            box-shadow: 0 0 20px #f39c12;
        }

        .tree-node.visited {
            background-color: #2ecc71;
            box-shadow: 0 0 15px #2ecc71;
        }

        .tree-connector {
            position: absolute;
            background-color: #5dade2;
            width: 2px;
        }

        .tree-connector.horizontal {
            height: 2px;
        }

        .tree-connector.vertical {
            width: 2px;
        }

        .graph-container {
            position: relative;
            width: 600px;
            height: 400px;
            margin: 30px auto;
            border: 1px solid #aed6f1;
            border-radius: 5px;
            background-color: #ffffff;
        }

        .graph-node {
            position: absolute;
            width: 40px;
            height: 40px;
            background-color: #76b5c5;
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 50%;
            font-weight: bold;
            cursor: pointer;
            z-index: 10;
            box-shadow: 0 0 5px rgba(118, 181, 197, 0.6);
        }

        .graph-node.active {
            background-color: #f39c12;
            box-shadow: 0 0 20px #f39c12;
        }

        .graph-node.visited {
            background-color: #2ecc71;
            box-shadow: 0 0 15px #2ecc71;
        }

        .graph-edge {
            position: absolute;
            background-color: #5dade2;
            height: 2px;
            transform-origin: 0 0;
            z-index: 1;
        }

        .graph-edge.directed::after {
            content: '';
            position: absolute;
            right: 0;
            top: -4px;
            width: 0;
            height: 0;
            border-top: 5px solid transparent;
            border-bottom: 5px solid transparent;
            border-left: 8px solid #5dade2;
        }

        .controls {
            display: flex;
            justify-content: center;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .control-group {
            margin: 0 15px;
        }

        button {
            background-color: #5dade2;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 12px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
            box-shadow: 0 0 10px rgba(93, 173, 226, 0.5);
            font-family: 'Orbitron', sans-serif;
        }

        button:hover {
            background-color: #85c1e9;
            transform: scale(1.05);
            box-shadow: 0 0 15px #aed6f1;
        }

        button:disabled {
            background-color: #bdc3c7;
            color: #7f8c8d;
            cursor: not-allowed;
        }

        input, select {
            padding: 8px 12px;
            margin: 5px;
            border-radius: 5px;
            border: 1px solid #aed6f1;
            background-color: #ecf0f1;
            color: #2c3e50;
            font-family: 'Orbitron', sans-serif;
        }

        label {
            margin-right: 5px;
            color: #34495e;
        }

        .speed-control {
            display: flex;
            align-items: center;
        }

        .status {
            margin: 15px 0;
            font-size: 18px;
            min-height: 27px;
            color: #2c3e50;
        }

        .complexity-info {
            background-color: #ecf0f1;
            padding: 15px;
            border-radius: 5px;
            margin: 15px 0;
            text-align: left;
            border: 1px solid #d1e3f0;
        }

        .complexity-info h4 {
            margin-top: 0;
            color: #2980b9;
        }

        pre {
            background-color: #ecf0f1;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            text-align: left;
            border: 1px solid #d1e3f0;
            color: #2c3e50;
        }

        .legend {
            display: flex;
            justify-content: center;
            margin: 15px 0;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin: 0 15px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            margin-right: 8px;
        }

        .legend-text {
            font-size: 14px;
            color: #34495e;
        }

        /* Additional styles for the blue theme */
        .swapping {
            background-color: #f39c12 !important;
            transform: translateY(-20px);
            box-shadow: 0 0 20px #f39c12;
            z-index: 10;
        }

        .sorted {
            background-color: #2ecc71 !important;
            box-shadow: 0 0 15px #2ecc71;
        }

        .merge-range {
            background-color: #9b59b6;
        }

        .merge-mid {
            background-color: #e74c3c;
        }

        .pivot {
            background-color: #f1c40f;
            color: #2c3e50;
        }

        .partitioned {
            background-color: #3498db;
        }

        .in-heap {
            background-color: #e67e22;
        }

        .reset-btn {
            background-color: #e74c3c;
            box-shadow: 0 0 10px rgba(231, 76, 60, 0.5);
        }

        .reset-btn:hover {
            background-color: #ec7063;
            box-shadow: 0 0 15px rgba(236, 112, 99, 0.7);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Data Structures & Algorithms Visualizer</h1>
        
        <!-- Searching Algorithms Section -->
        <div class="section">
            <h2>Searching Algorithms</h2>
            <div class="tab-buttons">
                <button class="tab-button active" onclick="showSearchTab('linear-search')">Linear Search</button>
                <button class="tab-button" onclick="showSearchTab('binary-search')">Binary Search</button>
            </div>
            
            <div id="linear-search" class="tab-content active">
                <div class="complexity-info">
                    <h4>Linear Search Complexity</h4>
                    <p><strong>Time Complexity:</strong> O(n)</p>
                    <p><strong>Space Complexity:</strong> O(1)</p>
                    <p>Linear search checks each element in the array sequentially until the target is found or the end is reached.</p>
                </div>
                
                <div class="controls">
                    <div class="control-group">
                        <label for="linear-array-size">Array Size:</label>
                        <select id="linear-array-size">
                            <option value="10">10</option>
                            <option value="15">15</option>
                            <option value="20">20</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label for="linear-target">Target Value:</label>
                        <input type="number" id="linear-target" min="1" max="100" value="42">
                    </div>
                    <button onclick="generateLinearArray()">Generate Array</button>
                    <button id="linear-start-btn" onclick="startLinearSearch()">Start Search</button>
                    <button onclick="resetLinearSearch()">Reset</button>
                </div>
                
                <div class="status" id="linear-status">Ready to search</div>
                
                <div class="visualization-container">
                    <div class="search-array" id="linear-array"></div>
                </div>
                
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #00bcd4;"></div>
                        <div class="legend-text">Element</div>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #ff00ff;"></div>
                        <div class="legend-text">Current</div>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #9b59b6;"></div>
                        <div class="legend-text">Checked</div>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #2ecc71;"></div>
                        <div class="legend-text">Found</div>
                    </div>
                </div>
            </div>
            
            <div id="binary-search" class="tab-content">
                <div class="complexity-info">
                    <h4>Binary Search Complexity</h4>
                    <p><strong>Time Complexity:</strong> O(log n)</p>
                    <p><strong>Space Complexity:</strong> O(1)</p>
                    <p>Binary search requires a sorted array. It repeatedly divides the search interval in half.</p>
                </div>
                
                <div class="controls">
                    <div class="control-group">
                        <label for="binary-array-size">Array Size:</label>
                        <select id="binary-array-size">
                            <option value="10">10</option>
                            <option value="15">15</option>
                            <option value="20">20</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label for="binary-target">Target Value:</label>
                        <input type="number" id="binary-target" min="1" max="100" value="42">
                    </div>
                    <button onclick="generateBinaryArray()">Generate Array</button>
                    <button id="binary-start-btn" onclick="startBinarySearch()">Start Search</button>
                    <button onclick="resetBinarySearch()">Reset</button>
                </div>
                
                <div class="status" id="binary-status">Ready to search</div>
                
                <div class="visualization-container">
                    <div class="search-array" id="binary-array"></div>
                </div>
                
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #00bcd4;"></div>
                        <div class="legend-text">Element</div>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #ff00ff;"></div>
                        <div class="legend-text">Current</div>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #9b59b6;"></div>
                        <div class="legend-text">Checked</div>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #2ecc71;"></div>
                        <div class="legend-text">Found</div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Data Structures Section -->
        <div class="section">
            <h2>Data Structures</h2>
            <div class="tab-buttons">
                <button class="tab-button active" onclick="showDsTab('array-tab')">Array</button>
                <button class="tab-button" onclick="showDsTab('stack-tab')">Stack</button>
                <button class="tab-button" onclick="showDsTab('queue-tab')">Queue</button>
                <button class="tab-button" onclick="showDsTab('linked-list-tab')">Linked List</button>
                <button class="tab-button" onclick="showDsTab('tree-tab')">Tree</button>
                <button class="tab-button" onclick="showDsTab('graph-tab')">Graph</button>
            </div>
            
            <div id="array-tab" class="tab-content active">
                <div class="complexity-info">
                    <h4>Array Operations Complexity</h4>
                    <p><strong>Access:</strong> O(1)</p>
                    <p><strong>Search:</strong> O(n)</p>
                    <p><strong>Insertion:</strong> O(n)</p>
                    <p><strong>Deletion:</strong> O(n)</p>
                    <p>Arrays store elements in contiguous memory locations, allowing constant time access.</p>
                </div>
                
                <div class="controls">
                    <div class="control-group">
                        <label for="array-size">Array Size:</label>
                        <select id="array-size">
                            <option value="5">5</option>
                            <option value="10">10</option>
                            <option value="15">15</option>
                        </select>
                    </div>
                    <button onclick="generateArray()">Generate Array</button>
                    <div class="control-group">
                        <label for="array-value">Value:</label>
                        <input type="number" id="array-value" min="1" max="100" value="42">
                    </div>
                    <div class="control-group">
                        <label for="array-index">Index:</label>
                        <input type="number" id="array-index" min="0" max="14" value="0">
                    </div>
                    <button onclick="accessArray()">Access</button>
                    <button onclick="insertArray()">Insert</button>
                    <button onclick="deleteArray()">Delete</button>
                </div>
                
                <div class="status" id="array-status">Array operations will be shown here</div>
                
                <div class="visualization-container">
                    <div class="ds-array" id="array-visual"></div>
                </div>
            </div>
            
            <div id="stack-tab" class="tab-content">
                <div class="complexity-info">
                    <h4>Stack Operations Complexity</h4>
                    <p><strong>Push:</strong> O(1)</p>
                    <p><strong>Pop:</strong> O(1)</p>
                    <p><strong>Peek:</strong> O(1)</p>
                    <p>Stack follows LIFO (Last In First Out) principle. Elements are added and removed from the top.</p>
                </div>
                
                <div class="controls">
                    <div class="control-group">
                        <label for="stack-value">Value:</label>
                        <input type="number" id="stack-value" min="1" max="100" value="42">
                    </div>
                    <button onclick="pushStack()">Push</button>
                    <button onclick="popStack()">Pop</button>
                    <button onclick="peekStack()">Peek</button>
                    <button onclick="clearStack()">Clear</button>
                </div>
                
                <div class="status" id="stack-status">Stack operations will be shown here</div>
                
                <div class="visualization-container">
                    <div class="stack-container" id="stack-visual"></div>
                </div>
            </div>
            
            <div id="queue-tab" class="tab-content">
                <div class="complexity-info">
                    <h4>Queue Operations Complexity</h4>
                    <p><strong>Enqueue:</strong> O(1)</p>
                    <p><strong>Dequeue:</strong> O(1)</p>
                    <p><strong>Peek:</strong> O(1)</p>
                    <p>Queue follows FIFO (First In First Out) principle. Elements are added at rear and removed from front.</p>
                </div>
                
                <div class="controls">
                    <div class="control-group">
                        <label for="queue-value">Value:</label>
                        <input type="number" id="queue-value" min="1" max="100" value="42">
                    </div>
                    <button onclick="enqueue()">Enqueue</button>
                    <button onclick="dequeue()">Dequeue</button>
                    <button onclick="peekQueue()">Peek</button>
                    <button onclick="clearQueue()">Clear</button>
                </div>
                
                <div class="status" id="queue-status">Queue operations will be shown here</div>
                
                <div class="visualization-container">
                    <div class="queue-container" id="queue-visual"></div>
                </div>
            </div>
            
            <div id="linked-list-tab" class="tab-content">
                <div class="complexity-info">
                    <h4>Linked List Operations Complexity</h4>
                    <p><strong>Access:</strong> O(n)</p>
                    <p><strong>Search:</strong> O(n)</p>
                    <p><strong>Insertion:</strong> O(1) at head, O(n) elsewhere</p>
                    <p><strong>Deletion:</strong> O(1) at head, O(n) elsewhere</p>
                    <p>Linked list consists of nodes where each node contains data and a reference to the next node.</p>
                </div>
                
                <div class="controls">
                    <div class="control-group">
                        <label for="ll-value">Value:</label>
                        <input type="number" id="ll-value" min="1" max="100" value="42">
                    </div>
                    <div class="control-group">
                        <label for="ll-position">Position:</label>
                        <input type="number" id="ll-position" min="0" value="0">
                    </div>
                    <button onclick="insertLinkedList()">Insert</button>
                    <button onclick="deleteLinkedList()">Delete</button>
                    <button onclick="searchLinkedList()">Search</button>
                    <button onclick="clearLinkedList()">Clear</button>
                </div>
                
                <div class="status" id="ll-status">Linked list operations will be shown here</div>
                
                <div class="visualization-container">
                    <div class="linked-list-container" id="linked-list-visual"></div>
                </div>
            </div>
            
            <div id="tree-tab" class="tab-content">
                <div class="complexity-info">
                    <h4>Binary Tree Operations Complexity</h4>
                    <p><strong>Access:</strong> O(n)</p>
                    <p><strong>Search:</strong> O(n)</p>
                    <p><strong>Insertion:</strong> O(n)</p>
                    <p><strong>Deletion:</strong> O(n)</p>
                    <p>Binary tree is a hierarchical data structure where each node has at most two children.</p>
                </div>
                
                <div class="controls">
                    <div class="control-group">
                        <label for="tree-value">Value:</label>
                        <input type="number" id="tree-value" min="1" max="100" value="42">
                    </div>
                    <button onclick="insertTreeNode()">Insert</button>
                    <button onclick="deleteTreeNode()">Delete</button>
                    <button onclick="searchTreeNode()">Search</button>
                    <button onclick="startTreeTraversal('dfs')">DFS Traversal</button>
                    <button onclick="clearTree()">Clear</button>
                </div>
                
                <div class="status" id="tree-status">Tree operations will be shown here</div>
                
                <div class="visualization-container">
                    <div class="tree-container">
                        <div class="tree" id="tree-visual"></div>
                    </div>
                </div>
            </div>
            
            <div id="graph-tab" class="tab-content">
                <div class="complexity-info">
                    <h4>Graph Operations Complexity</h4>
                    <p><strong>DFS/BFS:</strong> O(V + E)</p>
                    <p><strong>Space:</strong> O(V)</p>
                    <p>Graph consists of vertices (nodes) connected by edges. DFS explores as far as possible along each branch before backtracking.</p>
                </div>
                
                <div class="controls">
                    <button onclick="generateGraph()">Generate Graph</button>
                    <button onclick="startGraphTraversal('dfs')">DFS Traversal</button>
                    <button onclick="clearGraph()">Clear</button>
                    <div class="control-group">
                        <label for="graph-type">Graph Type:</label>
                        <select id="graph-type">
                            <option value="undirected">Undirected</option>
                            <option value="directed">Directed</option>
                        </select>
                    </div>
                </div>
                
                <div class="status" id="graph-status">Graph operations will be shown here</div>
                
                <div class="visualization-container">
                    <div class="graph-container" id="graph-visual"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let currentSearchTab = 'linear-search';
        let currentDsTab = 'array-tab';
        let isSearching = false;
        let isTraversing = false;
        let speed = 5;
        
        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            generateLinearArray();
            generateBinaryArray();
            generateArray();
            generateGraph();
        });
        
        // Tab navigation functions
        function showSearchTab(tabId) {
            document.getElementById(currentSearchTab).classList.remove('active');
            document.querySelector(`.tab-button[onclick="showSearchTab('${currentSearchTab}')"]`).classList.remove('active');
            
            document.getElementById(tabId).classList.add('active');
            document.querySelector(`.tab-button[onclick="showSearchTab('${tabId}')"]`).classList.add('active');
            
            currentSearchTab = tabId;
        }
        
        function showDsTab(tabId) {
            document.getElementById(currentDsTab).classList.remove('active');
            document.querySelector(`.tab-button[onclick="showDsTab('${currentDsTab}')"]`).classList.remove('active');
            
            document.getElementById(tabId).classList.add('active');
            document.querySelector(`.tab-button[onclick="showDsTab('${tabId}')"]`).classList.add('active');
            
            currentDsTab = tabId;
        }
        
        // Utility functions
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
        
        function getRandomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }
        
        // Searching Algorithms
        // Linear Search
        let linearArray = [];
        let linearSearchIndex = 0;
        let linearTarget = 42;
        
        function generateLinearArray() {
            const size = parseInt(document.getElementById('linear-array-size').value);
            linearArray = [];
            linearSearchIndex = 0;
            
            for (let i = 0; i < size; i++) {
                linearArray.push(getRandomInt(1, 100));
            }
            
            renderLinearArray();
            document.getElementById('linear-status').textContent = 'Array generated. Ready to search.';
            document.getElementById('linear-start-btn').disabled = false;
        }
        
        function renderLinearArray() {
            const container = document.getElementById('linear-array');
            container.innerHTML = '';
            
            linearArray.forEach((value, index) => {
                const element = document.createElement('div');
                element.className = 'search-element';
                element.textContent = value;
                element.style.height = `${value * 1.5}px`;
                
                if (index === linearSearchIndex && isSearching) {
                    element.classList.add('current');
                }
                
                container.appendChild(element);
            });
        }
        
        async function startLinearSearch() {
            if (isSearching) return;
            
            isSearching = true;
            linearTarget = parseInt(document.getElementById('linear-target').value);
            document.getElementById('linear-start-btn').disabled = true;
            document.getElementById('linear-status').textContent = 'Searching...';
            
            let found = false;
            
            for (let i = 0; i < linearArray.length; i++) {
                linearSearchIndex = i;
                renderLinearArray();
                
                await sleep(1000 / speed);
                
                if (linearArray[i] === linearTarget) {
                    found = true;
                    document.getElementById('linear-status').textContent = `Found ${linearTarget} at index ${i}`;
                    document.querySelector(`#linear-array .search-element:nth-child(${i + 1})`).classList.add('found');
                    break;
                } else {
                    document.querySelector(`#linear-array .search-element:nth-child(${i + 1})`).classList.add('checked');
                }
            }
            
            if (!found) {
                document.getElementById('linear-status').textContent = `${linearTarget} not found in the array`;
            }
            
            isSearching = false;
            document.getElementById('linear-start-btn').disabled = false;
        }
        
        function resetLinearSearch() {
            isSearching = false;
            linearSearchIndex = 0;
            renderLinearArray();
            document.getElementById('linear-status').textContent = 'Ready to search';
            document.getElementById('linear-start-btn').disabled = false;
        }
        
        // Binary Search
        let binaryArray = [];
        let binaryLow = 0;
        let binaryHigh = 0;
        let binaryMid = 0;
        let binaryTarget = 42;
        
        function generateBinaryArray() {
            const size = parseInt(document.getElementById('binary-array-size').value);
            binaryArray = [];
            
            for (let i = 0; i < size; i++) {
                binaryArray.push(getRandomInt(1, 100));
            }
            
            // Sort the array for binary search
            binaryArray.sort((a, b) => a - b);
            binaryLow = 0;
            binaryHigh = binaryArray.length - 1;
            binaryMid = Math.floor((binaryLow + binaryHigh) / 2);
            
            renderBinaryArray();
            document.getElementById('binary-status').textContent = 'Sorted array generated. Ready to search.';
            document.getElementById('binary-start-btn').disabled = false;
        }
        
        function renderBinaryArray() {
            const container = document.getElementById('binary-array');
            container.innerHTML = '';
            
            binaryArray.forEach((value, index) => {
                const element = document.createElement('div');
                element.className = 'search-element';
                element.textContent = value;
                element.style.height = `${value * 1.5}px`;
                
                if (index === binaryMid && isSearching) {
                    element.classList.add('current');
                } else if (isSearching && (index < binaryLow || index > binaryHigh)) {
                    element.classList.add('checked');
                }
                
                container.appendChild(element);
            });
        }
        
        async function startBinarySearch() {
            if (isSearching) return;
            
            isSearching = true;
            binaryTarget = parseInt(document.getElementById('binary-target').value);
            binaryLow = 0;
            binaryHigh = binaryArray.length - 1;
            document.getElementById('binary-start-btn').disabled = true;
            document.getElementById('binary-status').textContent = 'Searching...';
            
            let found = false;
            
            while (binaryLow <= binaryHigh) {
                binaryMid = Math.floor((binaryLow + binaryHigh) / 2);
                renderBinaryArray();
                
                await sleep(1000 / speed);
                
                if (binaryArray[binaryMid] === binaryTarget) {
                    found = true;
                    document.getElementById('binary-status').textContent = `Found ${binaryTarget} at index ${binaryMid}`;
                    document.querySelector(`#binary-array .search-element:nth-child(${binaryMid + 1})`).classList.add('found');
                    break;
                } else if (binaryArray[binaryMid] < binaryTarget) {
                    binaryLow = binaryMid + 1;
                } else {
                    binaryHigh = binaryMid - 1;
                }
                
                renderBinaryArray();
                await sleep(1000 / speed);
            }
            
            if (!found) {
                document.getElementById('binary-status').textContent = `${binaryTarget} not found in the array`;
            }
            
            isSearching = false;
            document.getElementById('binary-start-btn').disabled = false;
        }
        
        function resetBinarySearch() {
            isSearching = false;
            binaryLow = 0;
            binaryHigh = binaryArray.length - 1;
            binaryMid = Math.floor((binaryLow + binaryHigh) / 2);
            renderBinaryArray();
            document.getElementById('binary-status').textContent = 'Ready to search';
            document.getElementById('binary-start-btn').disabled = false;
        }
        
        // Data Structures
        // Array
        let array = [];
        
        function generateArray() {
            const size = parseInt(document.getElementById('array-size').value);
            array = [];
            
            for (let i = 0; i < size; i++) {
                array.push(getRandomInt(1, 100));
            }
            
            renderArray();
            document.getElementById('array-status').textContent = 'Array generated. Ready for operations.';
        }
        
        function renderArray() {
            const container = document.getElementById('array-visual');
            container.innerHTML = '';
            
            array.forEach((value, index) => {
                const cell = document.createElement('div');
                cell.className = 'array-cell';
                cell.textContent = value;
                container.appendChild(cell);
            });
        }
        
        function accessArray() {
            const index = parseInt(document.getElementById('array-index').value);
            
            if (index >= 0 && index < array.length) {
                document.getElementById('array-status').textContent = `Value at index ${index}: ${array[index]}`;
                
                // Highlight the accessed element
                const cells = document.querySelectorAll('#array-visual .array-cell');
                cells.forEach(cell => cell.style.backgroundColor = '#00bcd4');
                cells[index].style.backgroundColor = '#ff00ff';
                
                setTimeout(() => {
                    cells[index].style.backgroundColor = '#00bcd4';
                }, 1000);
            } else {
                document.getElementById('array-status').textContent = 'Invalid index!';
            }
        }
        
        function insertArray() {
            const value = parseInt(document.getElementById('array-value').value);
            const index = parseInt(document.getElementById('array-index').value);
            
            if (index >= 0 && index <= array.length) {
                array.splice(index, 0, value);
                renderArray();
                document.getElementById('array-status').textContent = `Inserted ${value} at index ${index}`;
                
                // Highlight the inserted element
                const cells = document.querySelectorAll('#array-visual .array-cell');
                cells[index].style.backgroundColor = '#ff00ff';
                
                setTimeout(() => {
                    cells[index].style.backgroundColor = '#00bcd4';
                }, 1000);
            } else {
                document.getElementById('array-status').textContent = 'Invalid index!';
            }
        }
        
       function deleteArray() {
    const index = parseInt(document.getElementById('array-index').value);
    
    if (index >= 0 && index < array.length) {
        const deletedValue = array[index];
        array.splice(index, 1);
        renderArray();
        document.getElementById('array-status').textContent = `Deleted value ${deletedValue} from index ${index}`;
    } else {
        document.getElementById('array-status').textContent = 'Invalid index!';
    }
}

// Stack
let stack = [];

function renderStack() {
    const container = document.getElementById('stack-visual');
    container.innerHTML = '';
    
    stack.forEach((value, index) => {
        const element = document.createElement('div');
        element.className = 'stack-element';
        element.textContent = value;
        container.appendChild(element);
    });
}

function pushStack() {
    const value = parseInt(document.getElementById('stack-value').value);
    stack.push(value);
    renderStack();
    document.getElementById('stack-status').textContent = `Pushed ${value} to stack`;
    
    // Highlight the pushed element
    const elements = document.querySelectorAll('#stack-visual .stack-element');
    elements[elements.length - 1].classList.add('active');
    
    setTimeout(() => {
        elements[elements.length - 1].classList.remove('active');
    }, 1000);
}

function popStack() {
    if (stack.length === 0) {
        document.getElementById('stack-status').textContent = 'Stack is empty!';
        return;
    }
    
    const value = stack.pop();
    renderStack();
    document.getElementById('stack-status').textContent = `Popped ${value} from stack`;
}

function peekStack() {
    if (stack.length === 0) {
        document.getElementById('stack-status').textContent = 'Stack is empty!';
        return;
    }
    
    const value = stack[stack.length - 1];
    document.getElementById('stack-status').textContent = `Top element is ${value}`;
    
    // Highlight the top element
    const elements = document.querySelectorAll('#stack-visual .stack-element');
    elements[elements.length - 1].classList.add('active');
    
    setTimeout(() => {
        elements[elements.length - 1].classList.remove('active');
    }, 1000);
}

function clearStack() {
    stack = [];
    renderStack();
    document.getElementById('stack-status').textContent = 'Stack cleared';
}

// Queue
let queue = [];

function renderQueue() {
    const container = document.getElementById('queue-visual');
    container.innerHTML = '';
    
    queue.forEach((value, index) => {
        const element = document.createElement('div');
        element.className = 'queue-element';
        element.textContent = value;
        container.appendChild(element);
    });
}

function enqueue() {
    const value = parseInt(document.getElementById('queue-value').value);
    queue.push(value);
    renderQueue();
    document.getElementById('queue-status').textContent = `Enqueued ${value}`;
    
    // Highlight the enqueued element
    const elements = document.querySelectorAll('#queue-visual .queue-element');
    elements[elements.length - 1].classList.add('active');
    
    setTimeout(() => {
        elements[elements.length - 1].classList.remove('active');
    }, 1000);
}

function dequeue() {
    if (queue.length === 0) {
        document.getElementById('queue-status').textContent = 'Queue is empty!';
        return;
    }
    
    const value = queue.shift();
    renderQueue();
    document.getElementById('queue-status').textContent = `Dequeued ${value}`;
}

function peekQueue() {
    if (queue.length === 0) {
        document.getElementById('queue-status').textContent = 'Queue is empty!';
        return;
    }
    
    const value = queue[0];
    document.getElementById('queue-status').textContent = `Front element is ${value}`;
    
    // Highlight the front element
    const elements = document.querySelectorAll('#queue-visual .queue-element');
    elements[0].classList.add('active');
    
    setTimeout(() => {
        elements[0].classList.remove('active');
    }, 1000);
}

function clearQueue() {
    queue = [];
    renderQueue();
    document.getElementById('queue-status').textContent = 'Queue cleared';
}

// Linked List
class ListNode {
    constructor(value, next = null) {
        this.value = value;
        this.next = next;
    }
}

let linkedList = null;

function renderLinkedList() {
    const container = document.getElementById('linked-list-visual');
    container.innerHTML = '';
    
    let current = linkedList;
    
    while (current) {
        const node = document.createElement('div');
        node.className = 'node';
        
        const value = document.createElement('div');
        value.className = 'node-value';
        value.textContent = current.value;
        
        node.appendChild(value);
        
        if (current.next) {
            const pointer = document.createElement('div');
            pointer.className = 'node-pointer';
            node.appendChild(pointer);
        }
        
        container.appendChild(node);
        current = current.next;
    }
    
    if (!linkedList) {
        document.getElementById('ll-status').textContent = 'Linked list is empty';
    }
}

function insertLinkedList() {
    const value = parseInt(document.getElementById('ll-value').value);
    const position = parseInt(document.getElementById('ll-position').value);
    
    const newNode = new ListNode(value);
    
    if (position === 0) {
        newNode.next = linkedList;
        linkedList = newNode;
        document.getElementById('ll-status').textContent = `Inserted ${value} at head`;
    } else {
        let current = linkedList;
        let prev = null;
        let count = 0;
        
        while (current && count < position) {
            prev = current;
            current = current.next;
            count++;
        }
        
        if (count === position) {
            prev.next = newNode;
            newNode.next = current;
            document.getElementById('ll-status').textContent = `Inserted ${value} at position ${position}`;
        } else {
            document.getElementById('ll-status').textContent = 'Invalid position!';
            return;
        }
    }
    
    renderLinkedList();
    
    // Highlight the inserted node
    const nodes = document.querySelectorAll('#linked-list-visual .node');
    if (position === 0) {
        nodes[0].classList.add('active');
        setTimeout(() => {
            nodes[0].classList.remove('active');
        }, 1000);
    } else {
        nodes[position].classList.add('active');
        setTimeout(() => {
            nodes[position].classList.remove('active');
        }, 1000);
    }
}

function deleteLinkedList() {
    const position = parseInt(document.getElementById('ll-position').value);
    
    if (!linkedList) {
        document.getElementById('ll-status').textContent = 'Linked list is empty!';
        return;
    }
    
    if (position === 0) {
        const deletedValue = linkedList.value;
        linkedList = linkedList.next;
        document.getElementById('ll-status').textContent = `Deleted ${deletedValue} from head`;
    } else {
        let current = linkedList;
        let prev = null;
        let count = 0;
        
        while (current && count < position) {
            prev = current;
            current = current.next;
            count++;
        }
        
        if (current && count === position) {
            const deletedValue = current.value;
            prev.next = current.next;
            document.getElementById('ll-status').textContent = `Deleted ${deletedValue} from position ${position}`;
        } else {
            document.getElementById('ll-status').textContent = 'Invalid position!';
            return;
        }
    }
    
    renderLinkedList();
}

function searchLinkedList() {
    const value = parseInt(document.getElementById('ll-value').value);
    let current = linkedList;
    let position = 0;
    let found = false;
    
    while (current) {
        if (current.value === value) {
            found = true;
            break;
        }
        current = current.next;
        position++;
    }
    
    if (found) {
        document.getElementById('ll-status').textContent = `Found ${value} at position ${position}`;
        
        // Highlight the found node
        const nodes = document.querySelectorAll('#linked-list-visual .node');
        nodes[position].classList.add('active');
        
        setTimeout(() => {
            nodes[position].classList.remove('active');
        }, 1000);
    } else {
        document.getElementById('ll-status').textContent = `${value} not found in the linked list`;
    }
}

function clearLinkedList() {
    linkedList = null;
    renderLinkedList();
    document.getElementById('ll-status').textContent = 'Linked list cleared';
}

// Tree
class TreeNode {
    constructor(value, left = null, right = null) {
        this.value = value;
        this.left = left;
        this.right = right;
    }
}

let treeRoot = null;

function renderTree() {
    const container = document.getElementById('tree-visual');
    container.innerHTML = '';
    
    if (!treeRoot) {
        document.getElementById('tree-status').textContent = 'Tree is empty';
        return;
    }
    
    // Calculate tree levels for visualization
    const levels = getTreeLevels(treeRoot);
    
    levels.forEach((level, levelIndex) => {
        const levelDiv = document.createElement('div');
        levelDiv.className = 'tree-level';
        
        level.forEach(node => {
            if (node === null) return;
            
            const nodeDiv = document.createElement('div');
            nodeDiv.className = 'tree-node';
            nodeDiv.textContent = node.value;
            
            if (node.active) {
                nodeDiv.classList.add('active');
                delete node.active;
            }
            
            if (node.visited) {
                nodeDiv.classList.add('visited');
                delete node.visited;
            }
            
            levelDiv.appendChild(nodeDiv);
        });
        
        container.appendChild(levelDiv);
    });
}

function getTreeLevels(root) {
    if (!root) return [];
    
    const levels = [];
    const queue = [{node: root, level: 0}];
    
    while (queue.length > 0) {
        const {node, level} = queue.shift();
        
        if (!levels[level]) {
            levels[level] = [];
        }
        
        levels[level].push(node);
        
        if (node.left) {
            queue.push({node: node.left, level: level + 1});
        }
        
        if (node.right) {
            queue.push({node: node.right, level: level + 1});
        }
    }
    
    return levels;
}

function insertTreeNode() {
    const value = parseInt(document.getElementById('tree-value').value);
    
    if (!treeRoot) {
        treeRoot = new TreeNode(value);
        document.getElementById('tree-status').textContent = `Inserted ${value} as root`;
    } else {
        // Simple insertion (not balanced)
        const queue = [treeRoot];
        
        while (queue.length > 0) {
            const current = queue.shift();
            
            if (!current.left) {
                current.left = new TreeNode(value);
                document.getElementById('tree-status').textContent = `Inserted ${value} as left child of ${current.value}`;
                break;
            } else if (!current.right) {
                current.right = new TreeNode(value);
                document.getElementById('tree-status').textContent = `Inserted ${value} as right child of ${current.value}`;
                break;
            } else {
                queue.push(current.left);
                queue.push(current.right);
            }
        }
    }
    
    renderTree();
}

function deleteTreeNode() {
    const value = parseInt(document.getElementById('tree-value').value);
    
    if (!treeRoot) {
        document.getElementById('tree-status').textContent = 'Tree is empty!';
        return;
    }
    
    // Find the node to delete and the deepest node
    let nodeToDelete = null;
    let deepestNode = null;
    let deepestNodeParent = null;
    let isLeftChild = false;
    
    const queue = [{node: treeRoot, parent: null}];
    
    while (queue.length > 0) {
        const {node, parent} = queue.shift();
        
        if (node.value === value) {
            nodeToDelete = node;
        }
        
        if (node.left) {
            queue.push({node: node.left, parent: node});
        }
        
        if (node.right) {
            queue.push({node: node.right, parent: node});
        }
        
        // Track the last node (deepest node)
        if (queue.length === 0) {
            deepestNode = node;
            deepestNodeParent = parent;
            if (parent && parent.left === node) {
                isLeftChild = true;
            }
        }
    }
    
    if (!nodeToDelete) {
        document.getElementById('tree-status').textContent = `${value} not found in tree`;
        return;
    }
    
    // Replace the node to delete with the deepest node
    if (nodeToDelete === deepestNode) {
        // Node to delete is the deepest node
        if (deepestNodeParent) {
            if (isLeftChild) {
                deepestNodeParent.left = null;
            } else {
                deepestNodeParent.right = null;
            }
        } else {
            treeRoot = null;
        }
    } else {
        // Replace the node to delete with deepest node
        nodeToDelete.value = deepestNode.value;
        
        // Remove the deepest node
        if (deepestNodeParent) {
            if (isLeftChild) {
                deepestNodeParent.left = null;
            } else {
                deepestNodeParent.right = null;
            }
        }
    }
    
    document.getElementById('tree-status').textContent = `Deleted node with value ${value}`;
    renderTree();
}

function searchTreeNode() {
    const value = parseInt(document.getElementById('tree-value').value);
    
    if (!treeRoot) {
        document.getElementById('tree-status').textContent = 'Tree is empty!';
        return;
    }
    
    const queue = [treeRoot];
    
    while (queue.length > 0) {
        const current = queue.shift();
        
        if (current.value === value) {
            current.active = true;
            renderTree();
            document.getElementById('tree-status').textContent = `Found ${value} in the tree`;
            
            setTimeout(() => {
                const nodes = document.querySelectorAll('.tree-node');
                nodes.forEach(node => {
                    if (node.textContent === value.toString()) {
                        node.classList.remove('active');
                    }
                });
            }, 1000);
            
            return;
        }
        
        if (current.left) {
            queue.push(current.left);
        }
        
        if (current.right) {
            queue.push(current.right);
        }
    }
    
    document.getElementById('tree-status').textContent = `${value} not found in tree`;
}

async function startTreeTraversal(type) {
    if (isTraversing) return;
    
    isTraversing = true;
    document.getElementById('tree-status').textContent = `Performing ${type.toUpperCase()} traversal...`;
    
    if (type === 'dfs') {
        await dfsTraversal(treeRoot);
    }
    
    isTraversing = false;
}

async function dfsTraversal(node) {
    if (!node) return;
    
    // Visit current node
    node.active = true;
    renderTree();
    await sleep(1000 / speed);
    
    node.active = false;
    node.visited = true;
    renderTree();
    
    // Traverse left subtree
    await dfsTraversal(node.left);
    
    // Traverse right subtree
    await dfsTraversal(node.right);
}

function clearTree() {
    treeRoot = null;
    renderTree();
    document.getElementById('tree-status').textContent = 'Tree cleared';
}

// Graph
let graphNodes = [];
let graphEdges = [];
let graphAdjacencyList = {};

function generateGraph() {
    const type = document.getElementById('graph-type').value;
    graphNodes = [];
    graphEdges = [];
    graphAdjacencyList = {};
    
    // Create 6 nodes in a circular pattern
    const centerX = 300;
    const centerY = 200;
    const radius = 150;
    
    for (let i = 0; i < 6; i++) {
        const angle = (i * Math.PI * 2) / 6;
        const x = centerX + radius * Math.cos(angle);
        const y = centerY + radius * Math.sin(angle);
        
        graphNodes.push({
            id: i,
            value: i + 1,
            x: x,
            y: y
        });
        
        graphAdjacencyList[i] = [];
    }
    
    // Create edges
    if (type === 'undirected') {
        // Connect nodes in a circular pattern with some random connections
        for (let i = 0; i < 6; i++) {
            const next = (i + 1) % 6;
            addEdge(i, next, type);
            
            // Add some random connections
            if (Math.random() > 0.5 && i !== next) {
                const randomNode = Math.floor(Math.random() * 6);
                if (!graphAdjacencyList[i].includes(randomNode)) {
                    addEdge(i, randomNode, type);
                }
            }
        }
    } else {
        // Directed graph - create a more hierarchical structure
        addEdge(0, 1, type);
        addEdge(0, 2, type);
        addEdge(1, 3, type);
        addEdge(2, 4, type);
        addEdge(2, 5, type);
        addEdge(3, 5, type);
    }
    
    renderGraph();
    document.getElementById('graph-status').textContent = `${type === 'undirected' ? 'Undirected' : 'Directed'} graph generated`;
}

function addEdge(from, to, type) {
    if (!graphAdjacencyList[from].includes(to)) {
        graphAdjacencyList[from].push(to);
        graphEdges.push({from, to, type});
    }
    
    if (type === 'undirected' && !graphAdjacencyList[to].includes(from)) {
        graphAdjacencyList[to].push(from);
    }
}

function renderGraph() {
    const container = document.getElementById('graph-visual');
    container.innerHTML = '';
    
    // Draw edges first (so nodes appear on top)
    graphEdges.forEach(edge => {
        const fromNode = graphNodes.find(n => n.id === edge.from);
        const toNode = graphNodes.find(n => n.id === edge.to);
        
        if (fromNode && toNode) {
            const edgeElement = document.createElement('div');
            edgeElement.className = 'graph-edge';
            
            // Calculate edge position and length
            const length = Math.sqrt(
                Math.pow(toNode.x - fromNode.x, 2) + 
                Math.pow(toNode.y - fromNode.y, 2)
            );
            
            const angle = Math.atan2(
                toNode.y - fromNode.y,
                toNode.x - fromNode.x
            ) * 180 / Math.PI;
            
            edgeElement.style.width = `${length}px`;
            edgeElement.style.left = `${fromNode.x - 20}px`;
            edgeElement.style.top = `${fromNode.y - 20}px`;
            edgeElement.style.transform = `rotate(${angle}deg)`;
            
            if (edge.type === 'directed') {
                edgeElement.classList.add('directed');
            }
            
            container.appendChild(edgeElement);
        }
    });
    
    // Draw nodes
    graphNodes.forEach(node => {
        const nodeElement = document.createElement('div');
        nodeElement.className = 'graph-node';
        nodeElement.textContent = node.value;
        nodeElement.style.left = `${node.x - 20}px`;
        nodeElement.style.top = `${node.y - 20}px`;
        
        if (node.active) {
            nodeElement.classList.add('active');
            delete node.active;
        }
        
        if (node.visited) {
            nodeElement.classList.add('visited');
            delete node.visited;
        }
        
        container.appendChild(nodeElement);
    });
}

async function startGraphTraversal(type) {
    if (isTraversing || graphNodes.length === 0) return;
    
    isTraversing = true;
    document.getElementById('graph-status').textContent = `Performing ${type.toUpperCase()} traversal...`;
    
    // Reset all nodes
    graphNodes.forEach(node => {
        node.visited = false;
        node.active = false;
    });
    
    if (type === 'dfs') {
        await dfsGraphTraversal(0); // Start from node 0
    }
    
    isTraversing = false;
}

async function dfsGraphTraversal(nodeId) {
    const node = graphNodes.find(n => n.id === nodeId);
    if (!node || node.visited) return;
    
    // Visit current node
    node.active = true;
    renderGraph();
    await sleep(1000 / speed);
    
    node.active = false;
    node.visited = true;
    renderGraph();
    
    // Visit all neighbors
    for (const neighborId of graphAdjacencyList[nodeId]) {
        await dfsGraphTraversal(neighborId);
    }
}

function clearGraph() {
    graphNodes = [];
    graphEdges = [];
    graphAdjacencyList = {};
    renderGraph();
    document.getElementById('graph-status').textContent = 'Graph cleared';
}
</script>
</body>
</html>